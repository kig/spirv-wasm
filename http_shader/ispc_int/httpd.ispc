//
//////////////////////////////
// This ISPC kernel is autogenerated by spirv-cross.
//////////////////////////////
//

#include "spirvcross_stdlib.ispc"

//////////////////////////////
// Work Group
//////////////////////////////
static uniform int3 gl_WorkGroupSize = {32, 1, 1};


//////////////////////////////
// Resources
//////////////////////////////
struct header
{
    int2 name;
    int2 value;
};

struct requestBuffer
{
    int8 request[];
};


struct responseBuffer
{
    int8 response[];
};


struct inputBuffer
{
    int inputBytes[];
};


struct outputBuffer
{
    int outputBytes[];
};


struct heapBuffer
{
    int8 heap[];
};



//////////////////////////////
// Shader Code
//////////////////////////////
static SPIRV_INLINE void unpackRequest(varying int& byteIndex, varying int& index, uniform struct requestBuffer& v_114, uniform struct inputBuffer& v_779)
{
    varying int _782 = v_779.inputBytes[byteIndex];
    varying int len = _782;
    for (uniform int j = 0; j < min(256, (len / 4) + 1); j++)
    {
        varying int _802 = v_779.inputBytes[(byteIndex + j) + 1];
        varying int v = _802;
        varying int off = index + ((j * 4) * 32);
        v_114.request[off + 0] = (v >> 0) & 255;
        v_114.request[off + 32] = (v >> 8) & 255;
        v_114.request[off + 64] = (v >> 16) & 255;
        v_114.request[off + 96] = (v >> 24) & 255;
    }
}

static SPIRV_INLINE void readMethod(varying int& i, varying int& index, varying int& method, uniform struct requestBuffer& v_114)
{
    varying int j = index + (i * 32);
    varying int _142 = v_114.request[j + 0];
    varying bool _144 = _142 == 71;
    varying bool _153;
    if (_144)
    {
        varying int _150 = v_114.request[j + 32];
        _153 = _150 == 69;
    }
    else
    {
        _153 = _144;
    }
    varying bool _163;
    if (_153)
    {
        varying int _160 = v_114.request[j + 64];
        _163 = _160 == 84;
    }
    else
    {
        _163 = _153;
    }
    varying bool _172;
    if (_163)
    {
        varying int _170 = v_114.request[j + 96];
        _172 = _170 == 32;
    }
    else
    {
        _172 = _163;
    }
    if (_172)
    {
        method = 542393671;
        i += 4;
        return;
    }
    else
    {
        varying int _184 = v_114.request[j + 0];
        varying bool _186 = _184 == 80;
        varying bool _195;
        if (_186)
        {
            varying int _192 = v_114.request[j + 32];
            _195 = _192 == 79;
        }
        else
        {
            _195 = _186;
        }
        varying bool _204;
        if (_195)
        {
            varying int _201 = v_114.request[j + 64];
            _204 = _201 == 83;
        }
        else
        {
            _204 = _195;
        }
        varying bool _212;
        if (_204)
        {
            varying int _210 = v_114.request[j + 96];
            _212 = _210 == 84;
        }
        else
        {
            _212 = _204;
        }
        varying bool _221;
        if (_212)
        {
            varying int _219 = v_114.request[j + 128];
            _221 = _219 == 32;
        }
        else
        {
            _221 = _212;
        }
        if (_221)
        {
            method = 1414745936;
            i += 5;
            return;
        }
        else
        {
            varying int _233 = v_114.request[j + 0];
            varying bool _234 = _233 == 79;
            varying bool _243;
            if (_234)
            {
                varying int _241 = v_114.request[j + 192];
                _243 = _241 == 32;
            }
            else
            {
                _243 = _234;
            }
            if (_243)
            {
                method = 1230262351;
                i += 7;
                return;
            }
        }
    }
    method = 0;
    i = 1025;
}

static SPIRV_INLINE void readRequestUntilChar(varying int& i, varying int& index, uniform int& endChar, varying int2& str, uniform struct requestBuffer& v_114)
{
    str.x = i;
    for (;;)
    {
        varying int _106 = i;
        varying bool _108 = _106 < 1024;
        varying bool _126;
        if (_108)
        {
            varying int _123 = v_114.request[index + (i * 32)];
            _126 = _123 != endChar;
        }
        else
        {
            _126 = _108;
        }
        if (_126)
        {
            i++;
            continue;
        }
        else
        {
            break;
        }
    }
    str.y = i;
    i++;
}

static SPIRV_INLINE void readPath(varying int& i, varying int& index, varying int2& path, uniform struct requestBuffer& v_114)
{
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 32;
    varying int2 param_3;
    readRequestUntilChar(param, param_1, param_2, param_3, v_114);
    i = param;
    path = param_3;
}

static SPIRV_INLINE void readProtocol(varying int& i, varying int& index, varying int& protocol, uniform struct requestBuffer& v_114)
{
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 13;
    varying int2 param_3;
    readRequestUntilChar(param, param_1, param_2, param_3, v_114);
    i = param;
    varying int2 protocolString = param_3;
    varying int _272 = i;
    varying bool _273 = _272 < 1024;
    varying bool _284;
    if (_273)
    {
        varying int _281 = v_114.request[index + (i * 32)];
        _284 = _281 == 10;
    }
    else
    {
        _284 = _273;
    }
    if (_284)
    {
        i++;
        varying int _291 = protocolString.y;
        varying int _296 = v_114.request[index + ((_291 - 1) * 32)];
        if (_296 == 49)
        {
            protocol = 825110831;
        }
        else
        {
            protocol = 808333615;
        }
    }
    else
    {
        protocol = 0;
        i = 1025;
    }
}

static SPIRV_INLINE varying bool readHeader(varying int& i, varying int& index, varying struct header& hdr, uniform struct requestBuffer& v_114)
{
    varying int _310 = v_114.request[index + (i * 32)];
    if (_310 == 13)
    {
        i += 2;
        return (varying bool)true;
    }
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 58;
    varying int2 param_3;
    readRequestUntilChar(param, param_1, param_2, param_3, v_114);
    i = param;
    hdr.name = param_3;
    for (;;)
    {
        varying int _335 = i;
        varying bool _336 = _335 < 1024;
        varying bool _346;
        if (_336)
        {
            varying int _344 = v_114.request[index + (i * 32)];
            _346 = _344 == 32;
        }
        else
        {
            _346 = _336;
        }
        if (_346)
        {
            i++;
            continue;
        }
        else
        {
            break;
        }
    }
    varying int param_4 = i;
    varying int param_5 = index;
    uniform int param_6 = 13;
    varying int2 param_7;
    readRequestUntilChar(param_4, param_5, param_6, param_7, v_114);
    i = param_4;
    hdr.value = param_7;
    i++;
    return (varying bool)false;
}

static SPIRV_INLINE void writeCRLF(varying int& i, varying int& index, uniform struct responseBuffer& v_367)
{
    v_367.response[index + (i * 32)] = 13;
    i++;
    v_367.response[index + (i * 32)] = 10;
    i++;
}

static SPIRV_INLINE void writeStatus(varying int& i, varying int& index, uniform int& statusCode, uniform struct responseBuffer& v_367)
{
    uniform int _str[9] = { 72, 84, 84, 80, 47, 49, 46, 49, 32 };
    uniform int _s = 0;
    uniform int _e = 9;
    while (_s < _e)
    {
        uniform int _405 = _s;
        _s = _405 + 1;
        uniform int _408 = _str[_405];
        v_367.response[index + (i * 32)] = _408;
        i++;
    }
    if (statusCode == 200)
    {
        uniform int _str_1[6] = { 50, 48, 48, 32, 79, 75 };
        uniform int _s_1 = 0;
        uniform int _e_1 = 6;
        while (_s_1 < _e_1)
        {
            uniform int _440 = _s_1;
            _s_1 = _440 + 1;
            uniform int _443 = _str_1[_440];
            v_367.response[index + (i * 32)] = _443;
            i++;
        }
    }
    else
    {
        uniform int _str_2[9] = { 53, 48, 48, 32, 69, 114, 114, 111, 114 };
        uniform int _s_2 = 0;
        uniform int _e_2 = 9;
        while (_s_2 < _e_2)
        {
            uniform int _467 = _s_2;
            _s_2 = _467 + 1;
            uniform int _470 = _str_2[_467];
            v_367.response[index + (i * 32)] = _470;
            i++;
        }
    }
    varying int param = i;
    varying int param_1 = index;
    writeCRLF(param, param_1, v_367);
    i = param;
}

static SPIRV_INLINE void writeContentType(varying int& i, varying int& index, uniform int& contentType, uniform struct responseBuffer& v_367)
{
    uniform int contentTypeString[14] = { 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 32 };
    uniform int _str[14];
    for (uniform int ii = 0; ii < 14; ii++)
    {
        _str[ii] = contentTypeString[ii];
    }
    uniform int _s = 0;
    uniform int _e = 14;
    while (_s < _e)
    {
        uniform int _509 = _s;
        _s = _509 + 1;
        uniform int _512 = _str[_509];
        v_367.response[index + (i * 32)] = _512;
        i++;
    }
    if (contentType == 0)
    {
        uniform int _str_1[10] = { 116, 101, 120, 116, 47, 112, 108, 97, 105, 110 };
        uniform int _s_1 = 0;
        uniform int _e_1 = 10;
        while (_s_1 < _e_1)
        {
            uniform int _543 = _s_1;
            _s_1 = _543 + 1;
            uniform int _546 = _str_1[_543];
            v_367.response[index + (i * 32)] = _546;
            i++;
        }
    }
    else
    {
        uniform int _str_2[9] = { 116, 101, 120, 116, 47, 104, 116, 109, 108 };
        uniform int _s_2 = 0;
        uniform int _e_2 = 9;
        while (_s_2 < _e_2)
        {
            uniform int _569 = _s_2;
            _s_2 = _569 + 1;
            uniform int _572 = _str_2[_569];
            v_367.response[index + (i * 32)] = _572;
            i++;
        }
    }
    varying int param = i;
    varying int param_1 = index;
    writeCRLF(param, param_1, v_367);
    i = param;
}

static SPIRV_INLINE varying int error(varying int& index, uniform struct responseBuffer& v_367)
{
    varying int i = 0;
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 500;
    writeStatus(param, param_1, param_2, v_367);
    i = param;
    varying int param_3 = i;
    varying int param_4 = index;
    uniform int param_5 = 0;
    writeContentType(param_3, param_4, param_5, v_367);
    i = param_3;
    varying int param_6 = i;
    varying int param_7 = index;
    writeCRLF(param_6, param_7, v_367);
    i = param_6;
    return i;
}

static SPIRV_INLINE varying int strLen(varying int2& str)
{
    varying int _92 = str.y;
    varying int _95 = str.x;
    return _92 - _95;
}

static SPIRV_INLINE void writeBody(varying int& i, varying int& index, varying int2& path, varying struct header headers[32], uniform int& headerCount, uniform struct requestBuffer& v_114, uniform struct responseBuffer& v_367)
{
    uniform int _str[13] = { 72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33 };
    uniform int _s = 0;
    uniform int _e = 13;
    while (_s < _e)
    {
        uniform int _605 = _s;
        _s = _605 + 1;
        uniform int _608 = _str[_605];
        v_367.response[index + (i * 32)] = _608;
        i++;
    }
    v_367.response[index + (i * 32)] = 10;
    i++;
    for (uniform int j = 0; j < 32; j++)
    {
        if (j >= headerCount)
        {
            break;
        }
        varying int2 _636 = headers[j].name;
        varying int2 name = _636;
        varying int2 _640 = headers[j].value;
        varying int2 value = _640;
        varying int2 param = name;
        varying int2 param_1 = value;
        if ((((strLen(param) + 3) + strLen(param_1)) + i) > 1023)
        {
            break;
        }
        varying int _659 = name.x;
        varying int _s_1 = _659;
        varying int _662 = name.y;
        varying int _e_1 = _662;
        while (_s_1 < _e_1)
        {
            varying int _680 = v_114.request[index + (_s_1 * 32)];
            v_367.response[index + (i * 32)] = _680;
            i++;
            _s_1++;
        }
        varying int _str_1[2] = { 58, 32 };
        varying int _s_2 = 0;
        uniform int _e_2 = 2;
        while (_s_2 < _e_2)
        {
            varying int _705 = _s_2;
            _s_2 = _705 + 1;
            varying int _708 = _str_1[_705];
            v_367.response[index + (i * 32)] = _708;
            i++;
        }
        varying int _714 = value.x;
        varying int _s_3 = _714;
        varying int _717 = value.y;
        varying int _e_3 = _717;
        while (_s_3 < _e_3)
        {
            varying int _735 = v_114.request[index + (_s_3 * 32)];
            v_367.response[index + (i * 32)] = _735;
            i++;
            _s_3++;
        }
        v_367.response[index + (i * 32)] = 10;
        i++;
    }
}

static SPIRV_INLINE varying int handleRequest(varying int& index, uniform struct requestBuffer& v_114, uniform struct responseBuffer& v_367)
{
    uniform int headerCount = 0;
    varying int i = 0;
    varying int param = i;
    varying int param_1 = index;
    varying int param_2;
    readMethod(param, param_1, param_2, v_114);
    i = param;
    varying int method = param_2;
    varying int param_3 = i;
    varying int param_4 = index;
    varying int2 param_5;
    readPath(param_3, param_4, param_5, v_114);
    i = param_3;
    varying int2 path = param_5;
    varying int param_6 = i;
    varying int param_7 = index;
    varying int param_8;
    readProtocol(param_6, param_7, param_8, v_114);
    i = param_6;
    varying int protocol = param_8;
    varying struct header headers[32];
    for (uniform int j = 0; j < 32; j++)
    {
        varying int param_9 = i;
        varying int param_10 = index;
        varying struct header param_11;
        varying bool _955 = readHeader(param_9, param_10, param_11, v_114);
        i = param_9;
        headers[j] = param_11;
        if (_955)
        {
            break;
        }
        headerCount++;
    }
    if (i > 1024)
    {
        varying int param_12 = index;
        varying int _972 = error(param_12, v_367);
        return _972;
    }
    i = 0;
    varying int param_13 = i;
    varying int param_14 = index;
    uniform int param_15 = 200;
    writeStatus(param_13, param_14, param_15, v_367);
    i = param_13;
    varying int param_16 = i;
    varying int param_17 = index;
    uniform int param_18 = 0;
    writeContentType(param_16, param_17, param_18, v_367);
    i = param_16;
    varying int param_19 = i;
    varying int param_20 = index;
    writeCRLF(param_19, param_20, v_367);
    i = param_19;
    varying int param_21 = i;
    varying int param_22 = index;
    varying int2 param_23 = path;
    varying struct header param_24[32];
    for (uniform int ii = 0; ii < 32; ii++)
    {
        param_24[ii] = headers[ii];
    }
    uniform int param_25 = headerCount;
    writeBody(param_21, param_22, param_23, param_24, param_25, v_114, v_367);
    i = param_21;
    return i;
}

static SPIRV_INLINE void packResponse(varying int& byteIndex, varying int& index, varying int& len, uniform struct responseBuffer& v_367, uniform struct outputBuffer& v_842)
{
    v_842.outputBytes[byteIndex] = len;
    for (uniform int j = 1; j < min(256, (len / 4) + 1); j++)
    {
        varying int off = index + (((j * 4) - 4) * 32);
        varying int _871 = v_367.response[off + 0];
        varying int _877 = v_367.response[off + 32];
        varying int _883 = v_367.response[off + 64];
        varying int _889 = v_367.response[off + 96];
        varying int4 v = int4((_871 & 255) << 0, (_877 & 255) << 8, (_883 & 255) << 16, (_889 & 255) << 24);
        varying int _897 = v.x;
        varying int _899 = v.y;
        varying int _902 = v.z;
        varying int _906 = v.w;
        v_842.outputBytes[byteIndex + j] = ((_897 | _899) | _902) | _906;
    }
}

static SPIRV_INLINE void httpd_ispc_main( uniform struct outputBuffer& v_842,  uniform struct inputBuffer& v_779,  uniform struct responseBuffer& v_367,  uniform struct requestBuffer& v_114, uniform int3 gl_NumWorkGroups, varying int3 gl_GlobalInvocationID,  uniform struct heapBuffer& _1057)
{
    varying int _1015 = gl_GlobalInvocationID.x;
    varying int _1017 = gl_GlobalInvocationID.y;
    uniform int _1020 = gl_NumWorkGroups.x;
    varying int wgId = int_cast(_1015 + (_1017 * (_1020 * 32u)));
    varying int index = 32768 * (wgId / 32);
    index += (wgId & 31);
    varying int param = wgId * 256;
    varying int param_1 = index;
    unpackRequest(param, param_1, v_114, v_779);
    varying int param_2 = index;
    varying int _1044 = handleRequest(param_2, v_114, v_367);
    varying int len = _1044;
    varying int param_3 = wgId * 256;
    varying int param_4 = index;
    varying int param_5 = len;
    packResponse(param_3, param_4, param_5, v_367, v_842);
}


//////////////////////////////
// ISPC Entry Points
//////////////////////////////
export void httpd_dispatch_all(uniform int work_groups[3],  uniform struct outputBuffer& v_842,  uniform struct inputBuffer& v_779,  uniform struct responseBuffer& v_367,  uniform struct requestBuffer& v_114,  uniform struct heapBuffer& _1057)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    
    // Loop over the work group dimensions
    for(uniform int z = 0; z < gl_NumWorkGroups.z; z++)
    {
        for(uniform int y = 0; y < gl_NumWorkGroups.y; y++)
        {
            for(uniform int x = 0; x < gl_NumWorkGroups.x; x++)
            {
                uniform int3 gl_WorkGroupID = int3(x, y, z);
                
                // Vectorise the workgroup
                foreach(lx = 0 ... gl_WorkGroupSize.x)
                {
                    varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
                    varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
                    varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
                    
                    httpd_ispc_main( v_842,  v_779,  v_367,  v_114, gl_NumWorkGroups, gl_GlobalInvocationID,  _1057);
                }
            }
        }
    }
}

export void httpd_dispatch_single(uniform int work_group_ID[3], uniform int work_groups[3],  uniform struct outputBuffer& v_842,  uniform struct inputBuffer& v_779,  uniform struct responseBuffer& v_367,  uniform struct requestBuffer& v_114,  uniform struct heapBuffer& _1057)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    uniform int3 gl_WorkGroupID = int3(work_group_ID[0], work_group_ID[1], work_group_ID[2]);
    
    // Vectorise the workgroup
    foreach(lx = 0 ... gl_WorkGroupSize.x)
    {
        varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
        varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
        varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        
        httpd_ispc_main( v_842,  v_779,  v_367,  v_114, gl_NumWorkGroups, gl_GlobalInvocationID,  _1057);
    }
}

export void httpd_dispatch_all_tiled(uniform int work_groups[3],  uniform struct outputBuffer& v_842,  uniform struct inputBuffer& v_779,  uniform struct responseBuffer& v_367,  uniform struct requestBuffer& v_114,  uniform struct heapBuffer& _1057)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    
    // Loop over the work group dimensions
    for(uniform int z = 0; z < gl_NumWorkGroups.z; z++)
    {
        for(uniform int y = 0; y < gl_NumWorkGroups.y; y++)
        {
            for(uniform int x = 0; x < gl_NumWorkGroups.x; x++)
            {
                uniform int3 gl_WorkGroupID = int3(x, y, z);
                
                // Vectorise the workgroup
                foreach_tiled(lx = 0 ... gl_WorkGroupSize.x)
                {
                    varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
                    varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
                    varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
                    
                    httpd_ispc_main( v_842,  v_779,  v_367,  v_114, gl_NumWorkGroups, gl_GlobalInvocationID,  _1057);
                }
            }
        }
    }
}

export void httpd_dispatch_single_tiled(uniform int work_group_ID[3], uniform int work_groups[3],  uniform struct outputBuffer& v_842,  uniform struct inputBuffer& v_779,  uniform struct responseBuffer& v_367,  uniform struct requestBuffer& v_114,  uniform struct heapBuffer& _1057)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    uniform int3 gl_WorkGroupID = int3(work_group_ID[0], work_group_ID[1], work_group_ID[2]);
    
    // Vectorise the workgroup
    foreach_tiled(lx = 0 ... gl_WorkGroupSize.x)
    {
        varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
        varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
        varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        
        httpd_ispc_main( v_842,  v_779,  v_367,  v_114, gl_NumWorkGroups, gl_GlobalInvocationID,  _1057);
    }
}


export void httpd_get_workgroup_size(uniform int & wg_x, uniform int & wg_y, uniform int & wg_z)
{
    wg_x = gl_WorkGroupSize.x;
    wg_y = gl_WorkGroupSize.y;
    wg_z = gl_WorkGroupSize.z;
}

