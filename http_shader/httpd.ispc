//
//////////////////////////////
// This ISPC kernel is autogenerated by spirv-cross.
// Sun Jun  7 18:20:17 2020
//////////////////////////////
//

#include "spirvcross_stdlib.ispc"

//////////////////////////////
// Work Group
//////////////////////////////
static uniform int3 gl_WorkGroupSize = {32, 1, 1};


//////////////////////////////
// Resources
//////////////////////////////
struct header
{
    int2 name;
    int2 value;
};

struct requestBuffer
{
    int request[];
};


struct responseBuffer
{
    int response[];
};


struct inputBuffer
{
    int inputBytes[];
};


struct outputBuffer
{
    int outputBytes[];
};


struct heapBuffer
{
    int heap[];
};



//////////////////////////////
// Shader Code
//////////////////////////////
static SPIRV_INLINE void unpackRequest(varying int& byteIndex, varying int& index, uniform struct requestBuffer& v_113, uniform struct inputBuffer& v_780)
{
    varying int _785 = v_780.inputBytes[byteIndex + 255];
    varying int len = _785;
    for (uniform int j = 0; j < ((len / 4) + 1); j++)
    {
        varying int _802 = v_780.inputBytes[byteIndex + j];
        varying int v = _802;
        varying int off = index + ((j * 4) * 32);
        v_113.request[off + 0] = (v >> 0) & 255;
        v_113.request[off + 32] = (v >> 8) & 255;
        v_113.request[off + 64] = (v >> 16) & 255;
        v_113.request[off + 96] = (v >> 24) & 255;
    }
}

static SPIRV_INLINE void readMethod(varying int& i, varying int& index, varying int& method, uniform struct requestBuffer& v_113)
{
    varying int j = index + (i * 32);
    varying int _141 = v_113.request[j + 0];
    varying bool _143 = _141 == 71;
    varying bool _152;
    if (_143)
    {
        varying int _149 = v_113.request[j + 32];
        _152 = _149 == 69;
    }
    else
    {
        _152 = _143;
    }
    varying bool _162;
    if (_152)
    {
        varying int _159 = v_113.request[j + 64];
        _162 = _159 == 84;
    }
    else
    {
        _162 = _152;
    }
    varying bool _171;
    if (_162)
    {
        varying int _169 = v_113.request[j + 96];
        _171 = _169 == 32;
    }
    else
    {
        _171 = _162;
    }
    if (_171)
    {
        method = 542393671;
        i += 4;
        return;
    }
    else
    {
        varying int _183 = v_113.request[j + 0];
        varying bool _185 = _183 == 80;
        varying bool _194;
        if (_185)
        {
            varying int _191 = v_113.request[j + 32];
            _194 = _191 == 79;
        }
        else
        {
            _194 = _185;
        }
        varying bool _203;
        if (_194)
        {
            varying int _200 = v_113.request[j + 64];
            _203 = _200 == 83;
        }
        else
        {
            _203 = _194;
        }
        varying bool _211;
        if (_203)
        {
            varying int _209 = v_113.request[j + 96];
            _211 = _209 == 84;
        }
        else
        {
            _211 = _203;
        }
        varying bool _220;
        if (_211)
        {
            varying int _218 = v_113.request[j + 128];
            _220 = _218 == 32;
        }
        else
        {
            _220 = _211;
        }
        if (_220)
        {
            method = 1414745936;
            i += 5;
            return;
        }
        else
        {
            varying int _232 = v_113.request[j + 0];
            varying bool _233 = _232 == 79;
            varying bool _242;
            if (_233)
            {
                varying int _240 = v_113.request[j + 192];
                _242 = _240 == 32;
            }
            else
            {
                _242 = _233;
            }
            if (_242)
            {
                method = 1230262351;
                i += 7;
                return;
            }
        }
    }
    method = 0;
    i = 1025;
}

static SPIRV_INLINE void readRequestUntilChar(varying int& i, varying int& index, uniform int& endChar, varying int2& str, uniform struct requestBuffer& v_113)
{
    str.x = i;
    for (;;)
    {
        varying int _105 = i;
        varying bool _107 = _105 < 1024;
        varying bool _125;
        if (_107)
        {
            varying int _122 = v_113.request[index + (i * 32)];
            _125 = _122 != endChar;
        }
        else
        {
            _125 = _107;
        }
        if (_125)
        {
            i++;
            continue;
        }
        else
        {
            break;
        }
    }
    str.y = i;
    i++;
}

static SPIRV_INLINE void readPath(varying int& i, varying int& index, varying int2& path, uniform struct requestBuffer& v_113)
{
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 32;
    varying int2 param_3;
    readRequestUntilChar(param, param_1, param_2, param_3, v_113);
    i = param;
    path = param_3;
}

static SPIRV_INLINE void readProtocol(varying int& i, varying int& index, varying int& protocol, uniform struct requestBuffer& v_113)
{
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 13;
    varying int2 param_3;
    readRequestUntilChar(param, param_1, param_2, param_3, v_113);
    i = param;
    varying int2 protocolString = param_3;
    varying int _271 = i;
    varying bool _272 = _271 < 1024;
    varying bool _283;
    if (_272)
    {
        varying int _280 = v_113.request[index + (i * 32)];
        _283 = _280 == 10;
    }
    else
    {
        _283 = _272;
    }
    if (_283)
    {
        i++;
        varying int _290 = protocolString.y;
        varying int _295 = v_113.request[index + ((_290 - 1) * 32)];
        if (_295 == 49)
        {
            protocol = 825110831;
        }
        else
        {
            protocol = 808333615;
        }
    }
    else
    {
        protocol = 0;
        i = 1025;
    }
}

static SPIRV_INLINE varying bool readHeader(varying int& i, varying int& index, varying struct header& hdr, uniform struct requestBuffer& v_113)
{
    varying int _309 = v_113.request[index + (i * 32)];
    if (_309 == 13)
    {
        i += 2;
        return (varying bool)true;
    }
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 58;
    varying int2 param_3;
    readRequestUntilChar(param, param_1, param_2, param_3, v_113);
    i = param;
    hdr.name = param_3;
    for (;;)
    {
        varying int _334 = i;
        varying bool _335 = _334 < 1024;
        varying bool _345;
        if (_335)
        {
            varying int _343 = v_113.request[index + (i * 32)];
            _345 = _343 == 32;
        }
        else
        {
            _345 = _335;
        }
        if (_345)
        {
            i++;
            continue;
        }
        else
        {
            break;
        }
    }
    varying int param_4 = i;
    varying int param_5 = index;
    uniform int param_6 = 13;
    varying int2 param_7;
    readRequestUntilChar(param_4, param_5, param_6, param_7, v_113);
    i = param_4;
    hdr.value = param_7;
    i++;
    return (varying bool)false;
}

static SPIRV_INLINE void writeCRLF(varying int& i, varying int& index, uniform struct responseBuffer& v_366)
{
    v_366.response[index + (i * 32)] = 13;
    i++;
    v_366.response[index + (i * 32)] = 10;
    i++;
}

static SPIRV_INLINE void writeStatus(varying int& i, varying int& index, uniform int& statusCode, uniform struct responseBuffer& v_366)
{
    uniform int _str[9] = { 72, 84, 84, 80, 47, 49, 46, 49, 32 };
    uniform int _s = 0;
    uniform int _e = 9;
    while (_s < _e)
    {
        uniform int _404 = _s;
        _s = _404 + 1;
        uniform int _407 = _str[_404];
        v_366.response[index + (i * 32)] = _407;
        i++;
    }
    if (statusCode == 200)
    {
        uniform int _str_1[6] = { 50, 48, 48, 32, 79, 75 };
        uniform int _s_1 = 0;
        uniform int _e_1 = 6;
        while (_s_1 < _e_1)
        {
            uniform int _439 = _s_1;
            _s_1 = _439 + 1;
            uniform int _442 = _str_1[_439];
            v_366.response[index + (i * 32)] = _442;
            i++;
        }
    }
    else
    {
        uniform int _str_2[9] = { 53, 48, 48, 32, 69, 114, 114, 111, 114 };
        uniform int _s_2 = 0;
        uniform int _e_2 = 9;
        while (_s_2 < _e_2)
        {
            uniform int _466 = _s_2;
            _s_2 = _466 + 1;
            uniform int _469 = _str_2[_466];
            v_366.response[index + (i * 32)] = _469;
            i++;
        }
    }
    varying int param = i;
    varying int param_1 = index;
    writeCRLF(param, param_1, v_366);
    i = param;
}

static SPIRV_INLINE void writeContentType(varying int& i, varying int& index, uniform int& contentType, uniform struct responseBuffer& v_366)
{
    uniform int contentTypeString[14] = { 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 32 };
    uniform int _str[14];
    for (uniform int ii = 0; ii < 14; ii++)
    {
        _str[ii] = contentTypeString[ii];
    }
    uniform int _s = 0;
    uniform int _e = 14;
    while (_s < _e)
    {
        uniform int _508 = _s;
        _s = _508 + 1;
        uniform int _511 = _str[_508];
        v_366.response[index + (i * 32)] = _511;
        i++;
    }
    if (contentType == 0)
    {
        uniform int _str_1[10] = { 116, 101, 120, 116, 47, 112, 108, 97, 105, 110 };
        uniform int _s_1 = 0;
        uniform int _e_1 = 10;
        while (_s_1 < _e_1)
        {
            uniform int _542 = _s_1;
            _s_1 = _542 + 1;
            uniform int _545 = _str_1[_542];
            v_366.response[index + (i * 32)] = _545;
            i++;
        }
    }
    else
    {
        uniform int _str_2[9] = { 116, 101, 120, 116, 47, 104, 116, 109, 108 };
        uniform int _s_2 = 0;
        uniform int _e_2 = 9;
        while (_s_2 < _e_2)
        {
            uniform int _568 = _s_2;
            _s_2 = _568 + 1;
            uniform int _571 = _str_2[_568];
            v_366.response[index + (i * 32)] = _571;
            i++;
        }
    }
    varying int param = i;
    varying int param_1 = index;
    writeCRLF(param, param_1, v_366);
    i = param;
}

static SPIRV_INLINE void error(varying int& index, uniform struct responseBuffer& v_366)
{
    varying int i = 0;
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 500;
    writeStatus(param, param_1, param_2, v_366);
    i = param;
    varying int param_3 = i;
    varying int param_4 = index;
    uniform int param_5 = 0;
    writeContentType(param_3, param_4, param_5, v_366);
    i = param_3;
    varying int param_6 = i;
    varying int param_7 = index;
    writeCRLF(param_6, param_7, v_366);
    i = param_6;
    v_366.response[index + 32736] = i;
}

static SPIRV_INLINE varying int strLen(varying int2& str)
{
    varying int _91 = str.y;
    varying int _94 = str.x;
    return _91 - _94;
}

static SPIRV_INLINE void writeBody(varying int& i, varying int& index, varying int2& path, varying struct header headers[32], varying int& headerCount, uniform struct requestBuffer& v_113, uniform struct responseBuffer& v_366)
{
    uniform int _str[13] = { 72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33 };
    uniform int _s = 0;
    uniform int _e = 13;
    while (_s < _e)
    {
        uniform int _604 = _s;
        _s = _604 + 1;
        uniform int _607 = _str[_604];
        v_366.response[index + (i * 32)] = _607;
        i++;
    }
    v_366.response[index + (i * 32)] = 10;
    i++;
    for (uniform int j = 0; j < 32; j++)
    {
        if (j >= headerCount)
        {
            break;
        }
        varying int2 _635 = headers[j].name;
        varying int2 name = _635;
        varying int2 _639 = headers[j].value;
        varying int2 value = _639;
        varying int2 param = name;
        varying int2 param_1 = value;
        if ((((strLen(param) + 3) + strLen(param_1)) + i) > 1023)
        {
            break;
        }
        varying int _658 = name.x;
        varying int _s_1 = _658;
        varying int _661 = name.y;
        varying int _e_1 = _661;
        while (_s_1 < _e_1)
        {
            varying int _679 = v_113.request[index + (_s_1 * 32)];
            v_366.response[index + (i * 32)] = _679;
            i++;
            _s_1++;
        }
        varying int _str_1[2] = { 58, 32 };
        varying int _s_2 = 0;
        varying int _e_2 = 2;
        while (_s_2 < _e_2)
        {
            varying int _704 = _s_2;
            _s_2 = _704 + 1;
            varying int _707 = _str_1[_704];
            v_366.response[index + (i * 32)] = _707;
            i++;
        }
        varying int _713 = value.x;
        varying int _s_3 = _713;
        varying int _716 = value.y;
        varying int _e_3 = _716;
        while (_s_3 < _e_3)
        {
            varying int _734 = v_113.request[index + (_s_3 * 32)];
            v_366.response[index + (i * 32)] = _734;
            i++;
            _s_3++;
        }
        v_366.response[index + (i * 32)] = 10;
        i++;
    }
}

static SPIRV_INLINE void handleRequest(varying int& index, uniform struct requestBuffer& v_113, uniform struct responseBuffer& v_366)
{
    varying int headerCount = 0;
    varying int i = 0;
    varying int param = i;
    varying int param_1 = index;
    varying int param_2;
    readMethod(param, param_1, param_2, v_113);
    i = param;
    varying int method = param_2;
    varying int param_3 = i;
    varying int param_4 = index;
    varying int2 param_5;
    readPath(param_3, param_4, param_5, v_113);
    i = param_3;
    varying int2 path = param_5;
    varying int param_6 = i;
    varying int param_7 = index;
    varying int param_8;
    readProtocol(param_6, param_7, param_8, v_113);
    i = param_6;
    varying int protocol = param_8;
    varying struct header headers[32];
    for (varying int j = 0; j < 32; j++)
    {
        varying int param_9 = i;
        varying int param_10 = index;
        varying struct header param_11;
        varying bool _957 = readHeader(param_9, param_10, param_11, v_113);
        i = param_9;
        headers[j] = param_11;
        if (_957)
        {
            break;
        }
        headerCount++;
    }
    if (i > 1024)
    {
        varying int param_12 = index;
        error(param_12, v_366);
        return;
    }
    i = 0;
    varying int param_13 = i;
    varying int param_14 = index;
    uniform int param_15 = 200;
    writeStatus(param_13, param_14, param_15, v_366);
    i = param_13;
    varying int param_16 = i;
    varying int param_17 = index;
    uniform int param_18 = 0;
    writeContentType(param_16, param_17, param_18, v_366);
    i = param_16;
    varying int param_19 = i;
    varying int param_20 = index;
    writeCRLF(param_19, param_20, v_366);
    i = param_19;
    varying int param_21 = i;
    varying int param_22 = index;
    varying int2 param_23 = path;
    writeBody(param_21, param_22, param_23, headers, headerCount, v_113, v_366);
    i = param_21;
    v_366.response[index + 32736] = i;
}

static SPIRV_INLINE void packResponse(varying int& byteIndex, varying int& index, uniform struct responseBuffer& v_366, uniform struct outputBuffer& v_846)
{
    varying int _842 = v_366.response[index + 32736];
    varying int len = _842;
    v_846.outputBytes[byteIndex + 255] = len;
    for (uniform int j = 0; j < (len + 1); j++)
    {
        varying int off = index + ((j * 4) * 32);
        varying int _873 = v_366.response[off + 0];
        varying int _879 = v_366.response[off + 32];
        varying int _885 = v_366.response[off + 64];
        varying int _891 = v_366.response[off + 96];
        varying int4 v = int4((_873 & 255) << 0, (_879 & 255) << 8, (_885 & 255) << 16, (_891 & 255) << 24);
        varying int _899 = v.x;
        varying int _901 = v.y;
        varying int _904 = v.z;
        varying int _908 = v.w;
        v_846.outputBytes[byteIndex + j] = ((_899 | _901) | _904) | _908;
    }
}

static SPIRV_INLINE void httpd_ispc_main( uniform struct outputBuffer& v_846,  uniform struct inputBuffer& v_780,  uniform struct responseBuffer& v_366,  uniform struct requestBuffer& v_113, uniform int3 gl_NumWorkGroups, varying int3 gl_GlobalInvocationID,  uniform struct heapBuffer& _1058)
{
    varying int _1018 = gl_GlobalInvocationID.x;
    varying int _1020 = gl_GlobalInvocationID.y;
    uniform int _1023 = gl_NumWorkGroups.x;
    varying int wgId = int_cast(_1018 + (_1020 * (_1023 * 32u)));
    varying int index = 32768 * (wgId / 32);
    index += (wgId & 31);
    varying int param = wgId * 256;
    varying int param_1 = index;
    unpackRequest(param, param_1, v_113, v_780);
    varying int param_2 = index;
    handleRequest(param_2, v_113, v_366);
    varying int param_3 = wgId * 256;
    varying int param_4 = index;
    packResponse(param_3, param_4, v_366, v_846);
}


//////////////////////////////
// ISPC Entry Points
//////////////////////////////
export void httpd_dispatch_all(uniform int work_groups[3],  uniform struct outputBuffer& v_846,  uniform struct inputBuffer& v_780,  uniform struct responseBuffer& v_366,  uniform struct requestBuffer& v_113,  uniform struct heapBuffer& _1058)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    
    // Loop over the work group dimensions
    for(uniform int z = 0; z < gl_NumWorkGroups.z; z++)
    {
        for(uniform int y = 0; y < gl_NumWorkGroups.y; y++)
        {
            for(uniform int x = 0; x < gl_NumWorkGroups.x; x++)
            {
                uniform int3 gl_WorkGroupID = int3(x, y, z);
                
                // Vectorise the workgroup
                foreach(lx = 0 ... gl_WorkGroupSize.x)
                {
                    varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
                    varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
                    varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
                    
                    httpd_ispc_main( v_846,  v_780,  v_366,  v_113, gl_NumWorkGroups, gl_GlobalInvocationID,  _1058);
                }
            }
        }
    }
}

export void httpd_dispatch_single(uniform int work_group_ID[3], uniform int work_groups[3],  uniform struct outputBuffer& v_846,  uniform struct inputBuffer& v_780,  uniform struct responseBuffer& v_366,  uniform struct requestBuffer& v_113,  uniform struct heapBuffer& _1058)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    uniform int3 gl_WorkGroupID = int3(work_group_ID[0], work_group_ID[1], work_group_ID[2]);
    
    // Vectorise the workgroup
    foreach(lx = 0 ... gl_WorkGroupSize.x)
    {
        varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
        varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
        varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        
        httpd_ispc_main( v_846,  v_780,  v_366,  v_113, gl_NumWorkGroups, gl_GlobalInvocationID,  _1058);
    }
}

export void httpd_dispatch_all_tiled(uniform int work_groups[3],  uniform struct outputBuffer& v_846,  uniform struct inputBuffer& v_780,  uniform struct responseBuffer& v_366,  uniform struct requestBuffer& v_113,  uniform struct heapBuffer& _1058)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    
    // Loop over the work group dimensions
    for(uniform int z = 0; z < gl_NumWorkGroups.z; z++)
    {
        for(uniform int y = 0; y < gl_NumWorkGroups.y; y++)
        {
            for(uniform int x = 0; x < gl_NumWorkGroups.x; x++)
            {
                uniform int3 gl_WorkGroupID = int3(x, y, z);
                
                // Vectorise the workgroup
                foreach_tiled(lx = 0 ... gl_WorkGroupSize.x)
                {
                    varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
                    varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
                    varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
                    
                    httpd_ispc_main( v_846,  v_780,  v_366,  v_113, gl_NumWorkGroups, gl_GlobalInvocationID,  _1058);
                }
            }
        }
    }
}

export void httpd_dispatch_single_tiled(uniform int work_group_ID[3], uniform int work_groups[3],  uniform struct outputBuffer& v_846,  uniform struct inputBuffer& v_780,  uniform struct responseBuffer& v_366,  uniform struct requestBuffer& v_113,  uniform struct heapBuffer& _1058)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    uniform int3 gl_WorkGroupID = int3(work_group_ID[0], work_group_ID[1], work_group_ID[2]);
    
    // Vectorise the workgroup
    foreach_tiled(lx = 0 ... gl_WorkGroupSize.x)
    {
        varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
        varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
        varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        
        httpd_ispc_main( v_846,  v_780,  v_366,  v_113, gl_NumWorkGroups, gl_GlobalInvocationID,  _1058);
    }
}


export void httpd_get_workgroup_size(uniform int & wg_x, uniform int & wg_y, uniform int & wg_z)
{
    wg_x = gl_WorkGroupSize.x;
    wg_y = gl_WorkGroupSize.y;
    wg_z = gl_WorkGroupSize.z;
}

