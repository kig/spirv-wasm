//
//////////////////////////////
// This ISPC kernel is autogenerated by spirv-cross.
//////////////////////////////
//

#include "spirvcross_stdlib.ispc"

//////////////////////////////
// Work Group
//////////////////////////////
static uniform int3 gl_WorkGroupSize = {32, 1, 1};


//////////////////////////////
// Resources
//////////////////////////////
struct header
{
    int2 name;
    int2 value;
};

struct inputBuffer
{
    int8 inputBytes[];
};


struct outputBuffer
{
    int8 outputBytes[];
};


struct heapBuffer
{
    int8 heap[];
};



//////////////////////////////
// Shader Code
//////////////////////////////
static SPIRV_INLINE void readMethod(varying int& i, varying int& index, varying int& method, uniform struct inputBuffer& v_88)
{
    varying int j = index + i;
    varying int _117 = v_88.inputBytes[j];
    varying int c = _117;
    varying int _120 = v_88.inputBytes[j];
    varying bool _122 = _120 == 71u;
    varying bool _131;
    if (_122)
    {
        varying int _128 = v_88.inputBytes[j + 1u];
        _131 = _128 == 69u;
    }
    else
    {
        _131 = _122;
    }
    varying bool _141;
    if (_131)
    {
        varying int _138 = v_88.inputBytes[j + 2u];
        _141 = _138 == 84u;
    }
    else
    {
        _141 = _131;
    }
    varying bool _151;
    if (_141)
    {
        varying int _148 = v_88.inputBytes[j + 3u];
        _151 = _148 == 32u;
    }
    else
    {
        _151 = _141;
    }
    if (_151)
    {
        method = 1u;
        i += 4u;
        return;
    }
    else
    {
        varying int _161 = v_88.inputBytes[j];
        varying bool _163 = _161 == 80u;
        varying bool _172;
        if (_163)
        {
            varying int _169 = v_88.inputBytes[j + 1u];
            _172 = _169 == 79u;
        }
        else
        {
            _172 = _163;
        }
        varying bool _181;
        if (_172)
        {
            varying int _178 = v_88.inputBytes[j + 2u];
            _181 = _178 == 83u;
        }
        else
        {
            _181 = _172;
        }
        varying bool _189;
        if (_181)
        {
            varying int _187 = v_88.inputBytes[j + 3u];
            _189 = _187 == 84u;
        }
        else
        {
            _189 = _181;
        }
        varying bool _197;
        if (_189)
        {
            varying int _195 = v_88.inputBytes[j + 4u];
            _197 = _195 == 32u;
        }
        else
        {
            _197 = _189;
        }
        if (_197)
        {
            method = 2u;
            i += 5u;
            return;
        }
        else
        {
            varying int _207 = v_88.inputBytes[j];
            varying bool _208 = _207 == 79u;
            varying bool _217;
            if (_208)
            {
                varying int _215 = v_88.inputBytes[j + 6u];
                _217 = _215 == 32u;
            }
            else
            {
                _217 = _208;
            }
            if (_217)
            {
                method = 3u;
                i += 7u;
                return;
            }
        }
    }
    method = 0u;
    i = 1025u;
}

static SPIRV_INLINE void writeStatus(varying int& i, varying int& index, uniform int& statusCode, uniform struct outputBuffer& v_353)
{
    varying int j = i + index;
    uniform int _str[9] = { 72u, 84u, 84u, 80u, 47u, 49u, 46u, 49u, 32u };
    uniform int _s = 0u;
    uniform int _e = 9u;
    while (_s < _e)
    {
        varying int _354 = j;
        j = _354 + (int)(1);
        uniform int _356 = _s;
        _s = _356 + (int)(1);
        uniform int _359 = _str[_356];
        v_353.outputBytes[_354] = _359;
    }
    if (statusCode == 200u)
    {
        uniform int _str_1[6] = { 50u, 48u, 48u, 32u, 79u, 75u };
        uniform int _s_1 = 0u;
        uniform int _e_1 = 6u;
        while (_s_1 < _e_1)
        {
            varying int _383 = j;
            j = _383 + (int)(1);
            uniform int _385 = _s_1;
            _s_1 = _385 + (int)(1);
            uniform int _388 = _str_1[_385];
            v_353.outputBytes[_383] = _388;
        }
    }
    else
    {
        uniform int _str_2[9] = { 53u, 48u, 48u, 32u, 69u, 114u, 114u, 111u, 114u };
        uniform int _s_2 = 0u;
        uniform int _e_2 = 9u;
        while (_s_2 < _e_2)
        {
            varying int _406 = j;
            j = _406 + (int)(1);
            uniform int _408 = _s_2;
            _s_2 = _408 + (int)(1);
            uniform int _411 = _str_2[_408];
            v_353.outputBytes[_406] = _411;
        }
    }
    varying int _413 = j;
    j = _413 + (int)(1);
    v_353.outputBytes[_413] = 13u;
    varying int _416 = j;
    j = _416 + (int)(1);
    v_353.outputBytes[_416] = 10u;
    i = j - index;
}

static SPIRV_INLINE void writeContentType(varying int& i, varying int& index, uniform int& contentType, uniform struct outputBuffer& v_353)
{
    varying int j = i + index;
    uniform int contentTypeString[14] = { 67u, 111u, 110u, 116u, 101u, 110u, 116u, 45u, 84u, 121u, 112u, 101u, 58u, 32u };
    uniform int _str[14];
    for (uniform int ii = 0; ii < 14; ii++)
    {
        _str[ii] = contentTypeString[ii];
    }
    uniform int _s = 0u;
    uniform int _e = 14u;
    while (_s < _e)
    {
        varying int _450 = j;
        j = _450 + (int)(1);
        uniform int _452 = _s;
        _s = _452 + (int)(1);
        uniform int _455 = _str[_452];
        v_353.outputBytes[_450] = _455;
    }
    if (contentType == 0u)
    {
        uniform int _str_1[10] = { 116u, 101u, 120u, 116u, 47u, 112u, 108u, 97u, 105u, 110u };
        uniform int _s_1 = 0u;
        uniform int _e_1 = 10u;
        while (_s_1 < _e_1)
        {
            varying int _479 = j;
            j = _479 + (int)(1);
            uniform int _481 = _s_1;
            _s_1 = _481 + (int)(1);
            uniform int _484 = _str_1[_481];
            v_353.outputBytes[_479] = _484;
        }
    }
    else
    {
        uniform int _str_2[9] = { 116u, 101u, 120u, 116u, 47u, 104u, 116u, 109u, 108u };
        uniform int _s_2 = 0u;
        uniform int _e_2 = 9u;
        while (_s_2 < _e_2)
        {
            varying int _501 = j;
            j = _501 + (int)(1);
            uniform int _503 = _s_2;
            _s_2 = _503 + (int)(1);
            uniform int _506 = _str_2[_503];
            v_353.outputBytes[_501] = _506;
        }
    }
    varying int _508 = j;
    j = _508 + (int)(1);
    v_353.outputBytes[_508] = 13u;
    varying int _511 = j;
    j = _511 + (int)(1);
    v_353.outputBytes[_511] = 10u;
    i = j - index;
}

static SPIRV_INLINE void writeEndHeaders(varying int& i, varying int& index, uniform struct outputBuffer& v_353)
{
    varying int j = i + index;
    varying int _521 = j;
    j = _521 + (int)(1);
    v_353.outputBytes[_521] = 13u;
    varying int _524 = j;
    j = _524 + (int)(1);
    v_353.outputBytes[_524] = 10u;
    i = j - index;
}

static SPIRV_INLINE void error(varying int& index, uniform struct outputBuffer& v_353)
{
    varying int i = 16u;
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 500u;
    writeStatus(param, param_1, param_2, v_353);
    i = param;
    varying int param_3 = i;
    varying int param_4 = index;
    uniform int param_5 = 0u;
    writeContentType(param_3, param_4, param_5, v_353);
    i = param_3;
    varying int param_6 = i;
    varying int param_7 = index;
    writeEndHeaders(param_6, param_7, v_353);
    i = param_6;
    v_353.outputBytes[index + 0u] = ((i - 16u) << (int)(0)) & 255u;
    v_353.outputBytes[index + 1u] = ((i - 16u) << (int)(8)) & 255u;
    v_353.outputBytes[index + 2u] = ((i - 16u) << (int)(16)) & 255u;
    v_353.outputBytes[index + 3u] = ((i - 16u) << (int)(24)) & 255u;
}

static SPIRV_INLINE void readRequestUntilChar(varying int& i, varying int& index, uniform int& endChar, varying int2& str, uniform struct inputBuffer& v_88)
{
    str.x = index + i;
    for (;;)
    {
        varying int _80 = i;
        varying bool _82 = _80 < 1024u;
        varying bool _99;
        if (_82)
        {
            varying int _96 = v_88.inputBytes[index + i];
            _99 = _96 != endChar;
        }
        else
        {
            _99 = _82;
        }
        if (_99)
        {
            i += (int)(1);
            continue;
        }
        else
        {
            break;
        }
    }
    str.y = index + i;
    i += (int)(1);
}

static SPIRV_INLINE void readPath(varying int& i, varying int& index, varying int2& path, uniform struct inputBuffer& v_88)
{
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 32u;
    varying int2 param_3;
    readRequestUntilChar(param, param_1, param_2, param_3, v_88);
    i = param;
    path = param_3;
}

static SPIRV_INLINE void readProtocol(varying int& i, varying int& index, varying int& protocol, uniform struct inputBuffer& v_88)
{
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 13u;
    varying int2 param_3;
    readRequestUntilChar(param, param_1, param_2, param_3, v_88);
    i = param;
    varying int2 protocolString = param_3;
    varying int _245 = i;
    varying bool _246 = _245 < 1024u;
    varying bool _256;
    if (_246)
    {
        varying int _253 = v_88.inputBytes[index + i];
        _256 = _253 == 10u;
    }
    else
    {
        _256 = _246;
    }
    if (_256)
    {
        i += (int)(1);
        varying int _262 = protocolString.y;
        varying int _265 = v_88.inputBytes[_262 - 1u];
        if (_265 == 49u)
        {
            protocol = 2u;
        }
        else
        {
            protocol = 1u;
        }
    }
    else
    {
        protocol = 0u;
        i = 1025u;
    }
}

static SPIRV_INLINE varying bool readHeader(varying int& i, varying int& index, varying struct header& hdr, uniform struct inputBuffer& v_88)
{
    varying int _276 = v_88.inputBytes[index + i];
    if (_276 == 13u)
    {
        i += 2u;
        return (varying bool)true;
    }
    varying int param = i;
    varying int param_1 = index;
    uniform int param_2 = 58u;
    varying int2 param_3;
    readRequestUntilChar(param, param_1, param_2, param_3, v_88);
    i = param;
    hdr.name = param_3;
    for (;;)
    {
        varying int _300 = i;
        varying bool _301 = _300 < 1024u;
        varying bool _310;
        if (_301)
        {
            varying int _308 = v_88.inputBytes[index + i];
            _310 = _308 == 32u;
        }
        else
        {
            _310 = _301;
        }
        if (_310)
        {
            i += (int)(1);
            continue;
        }
        else
        {
            break;
        }
    }
    varying int param_4 = i;
    varying int param_5 = index;
    uniform int param_6 = 13u;
    varying int2 param_7;
    readRequestUntilChar(param_4, param_5, param_6, param_7, v_88);
    i = param_4;
    hdr.value = param_7;
    i += (int)(1);
    return (varying bool)false;
}

static SPIRV_INLINE void writeBody(varying int& i, varying int& index, varying int2& path, uniform struct outputBuffer& v_353)
{
    varying int j = i + index;
    uniform int _str[13] = { 72u, 101u, 108u, 108u, 111u, 44u, 32u, 87u, 111u, 114u, 108u, 100u, 33u };
    uniform int _s = 0u;
    uniform int _e = 13u;
    while (_s < _e)
    {
        varying int _552 = j;
        j = _552 + (int)(1);
        uniform int _554 = _s;
        _s = _554 + (int)(1);
        uniform int _557 = _str[_554];
        v_353.outputBytes[_552] = _557;
    }
    varying int _559 = j;
    j = _559 + (int)(1);
    v_353.outputBytes[_559] = 10u;
    i = j - index;
}

static SPIRV_INLINE void handleRequest(varying int& index, uniform struct inputBuffer& v_88, uniform struct outputBuffer& v_353)
{
    varying int i = 16u;
    varying int headerCount = 0u;
    varying int param = i;
    varying int param_1 = index;
    varying int param_2;
    readMethod(param, param_1, param_2, v_88);
    i = param;
    varying int method = param_2;
    if (i > 1024u)
    {
        varying int param_3 = index;
        error(param_3, v_353);
        return;
    }
    varying int param_4 = i;
    varying int param_5 = index;
    varying int2 param_6;
    readPath(param_4, param_5, param_6, v_88);
    i = param_4;
    varying int2 path = param_6;
    if (i > 1024u)
    {
        varying int param_7 = index;
        error(param_7, v_353);
        return;
    }
    varying int param_8 = i;
    varying int param_9 = index;
    varying int param_10;
    readProtocol(param_8, param_9, param_10, v_88);
    i = param_8;
    varying int protocol = param_10;
    if (i > 1024u)
    {
        varying int param_11 = index;
        error(param_11, v_353);
        return;
    }
    for (uniform int j = 0u; j < 32u; j += (int)(1))
    {
        varying int param_12 = i;
        varying int param_13 = index;
        varying struct header param_14;
        varying bool _692 = readHeader(param_12, param_13, param_14, v_88);
        i = param_12;
        varying struct header headers[32];
        headers[j] = param_14;
        varying bool done = _692;
        if (i > 1024u)
        {
            varying int param_15 = index;
            error(param_15, v_353);
            return;
        }
        if (done)
        {
            break;
        }
        headerCount += (int)(1);
    }
    i = 16u;
    varying int param_16 = i;
    varying int param_17 = index;
    uniform int param_18 = 200u;
    writeStatus(param_16, param_17, param_18, v_353);
    i = param_16;
    varying int param_19 = i;
    varying int param_20 = index;
    uniform int param_21 = 0u;
    writeContentType(param_19, param_20, param_21, v_353);
    i = param_19;
    varying int param_22 = i;
    varying int param_23 = index;
    writeEndHeaders(param_22, param_23, v_353);
    i = param_22;
    varying int param_24 = i;
    varying int param_25 = index;
    varying int2 param_26 = path;
    writeBody(param_24, param_25, param_26, v_353);
    i = param_24;
    v_353.outputBytes[index + 0u] = ((i - 16u) << (int)(0)) & 255u;
    v_353.outputBytes[index + 1u] = ((i - 16u) << (int)(8)) & 255u;
    v_353.outputBytes[index + 2u] = ((i - 16u) << (int)(16)) & 255u;
    v_353.outputBytes[index + 3u] = ((i - 16u) << (int)(24)) & 255u;
}

static SPIRV_INLINE void httpd_ispc_main( uniform struct inputBuffer& v_88,  uniform struct outputBuffer& v_353, uniform int3 gl_NumWorkGroups, varying int3 gl_GlobalInvocationID,  uniform struct heapBuffer& _790)
{
    varying int index = 512u * 1024u * gl_GlobalInvocationID.x;
    for (uniform int i = 0; i < 512; i++) {
        handleRequest(index + i * 1024, v_88, v_353);
    }
}


//////////////////////////////
// ISPC Entry Points
//////////////////////////////
export void httpd_dispatch_all(uniform int work_groups[3],  uniform struct inputBuffer& v_88,  uniform struct outputBuffer& v_353,  uniform struct heapBuffer& _790)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    
    // Loop over the work group dimensions
    for(uniform int z = 0; z < gl_NumWorkGroups.z; z++)
    {
        for(uniform int y = 0; y < gl_NumWorkGroups.y; y++)
        {
            for(uniform int x = 0; x < gl_NumWorkGroups.x; x++)
            {
                uniform int3 gl_WorkGroupID = int3(x, y, z);
                
                // Vectorise the workgroup
                foreach(lx = 0 ... gl_WorkGroupSize.x)
                {
                    varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
                    varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
                    varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
                    
                    httpd_ispc_main( v_88,  v_353, gl_NumWorkGroups, gl_GlobalInvocationID,  _790);
                }
            }
        }
    }
}

export void httpd_dispatch_single(uniform int work_group_ID[3], uniform int work_groups[3],  uniform struct inputBuffer& v_88,  uniform struct outputBuffer& v_353,  uniform struct heapBuffer& _790)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    uniform int3 gl_WorkGroupID = int3(work_group_ID[0], work_group_ID[1], work_group_ID[2]);
    
    // Vectorise the workgroup
    foreach(lx = 0 ... gl_WorkGroupSize.x)
    {
        varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
        varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
        varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        
        httpd_ispc_main( v_88,  v_353, gl_NumWorkGroups, gl_GlobalInvocationID,  _790);
    }
}

export void httpd_dispatch_all_tiled(uniform int work_groups[3],  uniform struct inputBuffer& v_88,  uniform struct outputBuffer& v_353,  uniform struct heapBuffer& _790)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    
    // Loop over the work group dimensions
    for(uniform int z = 0; z < gl_NumWorkGroups.z; z++)
    {
        for(uniform int y = 0; y < gl_NumWorkGroups.y; y++)
        {
            for(uniform int x = 0; x < gl_NumWorkGroups.x; x++)
            {
                uniform int3 gl_WorkGroupID = int3(x, y, z);
                
                // Vectorise the workgroup
                foreach_tiled(lx = 0 ... gl_WorkGroupSize.x)
                {
                    varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
                    varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
                    varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
                    
                    httpd_ispc_main( v_88,  v_353, gl_NumWorkGroups, gl_GlobalInvocationID,  _790);
                }
            }
        }
    }
}

export void httpd_dispatch_single_tiled(uniform int work_group_ID[3], uniform int work_groups[3],  uniform struct inputBuffer& v_88,  uniform struct outputBuffer& v_353,  uniform struct heapBuffer& _790)
{
    uniform int3 gl_NumWorkGroups = int3(work_groups[0], work_groups[1], work_groups[2]);
    uniform int3 gl_WorkGroupID = int3(work_group_ID[0], work_group_ID[1], work_group_ID[2]);
    
    // Vectorise the workgroup
    foreach_tiled(lx = 0 ... gl_WorkGroupSize.x)
    {
        varying int3 gl_LocalInvocationID = int3(lx, 0, 0);
        varying int3 gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
        varying int gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
        
        httpd_ispc_main( v_88,  v_353, gl_NumWorkGroups, gl_GlobalInvocationID,  _790);
    }
}


export void httpd_get_workgroup_size(uniform int & wg_x, uniform int & wg_y, uniform int & wg_z)
{
    wg_x = gl_WorkGroupSize.x;
    wg_y = gl_WorkGroupSize.y;
    wg_z = gl_WorkGroupSize.z;
}

